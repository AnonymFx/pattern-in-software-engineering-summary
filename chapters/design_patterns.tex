%!TEX root = ../report.tex

\section{Design Patterns}
Design patterns are generalizations of detailed design knowledge from existing systems.
They provide a shared vocabulary and examples of reusable designs to designers (e.g. polymorphism, delegation/aggregation).

In summary, there are three types of design pattern:
\begin{itemize}
	\item \textbf{Structural Patterns}
		\begin{itemize}
			\item Reduce coupling between two or more classes
			\item Introduce an abstract class to enable future extensions
			\item Encapsulate complex structures
		\end{itemize}
	\item \textbf{Behavioral Patterns}
		\begin{itemize}
			\item Allow a choice between algorithms and the assignment of responsibilities to objects (\glqq Who does what?\grqq)
			\item Simplify complex control flows that are difficult to follow at runtime
		\end{itemize}
	\item \textbf{Creational Patterns}
		\begin{itemize}
			\item Allow a simplified view from complex instantiation processes
			\item Make the system independent from the way its objects are created,
			composed and represented
		\end{itemize}
\end{itemize}

The following sections list some of the most relevant patterns of those categories.

\newpage
\subsection{Structural Patterns}
Structural patterns aim for less coupling between classes and easier extensibility by encapsulating complex structures.

\subsubsection{Adapter Pattern/Wrapper}
Connects incompatible components to for example
\begin{itemize}
  \item Reuse existing components
  \item Convert an interface to another interface (maybe needed by an API call)
\end{itemize}

Structure:\\
\includegraphics[width=\linewidth]{images/pattern_adapter.png}
\newpage

\subsubsection{Bridge Pattern}
Allows to delay the assignment of an implementation of an interface from compile to run time.\\
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_bridge.png}
The \textbf{degenerated bridge pattern} is the same as the bridge pattern without the taxonomy in the application domain.
\newpage

\subsubsection{Proxy Pattern/Caching}
The proxy pattern allows to defer object creation and object initialization to the time you need the object (Remote Proxy (Caching), Substitute (Virtual Proxy), Protection Proxy (Access control/Firewall)).\\
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_proxy.png}
The client never calls request() in RealSubject, instead it always calls the method in Proxy which might delegate it to the RealSubject.
\newpage

\subsubsection{Composite Pattern}
The composite pattern models tree structures that represent part-whole hierarchies with arbitrary depth and width.
It lets the client treat individual objects and groups uniformly. \\
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_composite.png}
\newpage


\subsection{Behavioral Patterns}
Behavioral patterns identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication. %from wikipedia

\subsubsection{Strategy Pattern}
Suited for situations where different algorithms are available for a problem (e.g. sorting).\\
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_strategy.png}
A strategy is chosen on \textbf{runtime} by the Policy class before the client calls executeAlgorithm.
\newpage

\subsubsection{State Pattern}
Dependent on the current state of a system, an action should do different things (e.g. TCP open, close).
The state pattern avoids many if else statements and is flexible to add more cases/states.\\
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_state.png}
Problem: Where are state transactions handled? (in the exercise of the lecture in the states)
\newpage

\subsubsection{Observer Pattern}
The observer pattern handles changes in a publisher class and notifies all subscribers about that change (e.g. the user interface) to maintain consistency.
There are three variants for maintaining consistency:
\begin{itemize}
  \item \textbf{Push Notification:} Every time a state changes, all subscribers are notified
  \item \textbf{Push-Update Notification:} The publisher also sends the state that has changed
  \item \textbf{Pull Notification:} A subscriber inquires about the state of the publisher
\end{itemize}
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_observer.png}
\newpage

\subsubsection{Model View Controller Pattern}
The model-view-controller architectural style decouples data access and data representation.
The view handles the data representation, the model the data access and the controller handles the communication between the other two.\\
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_mvc.png}
In the \textbf{pull variant} the connection between the controller and the view is removed.
In this variant the view asks the model for the data explicitly.\\
In the \textbf{push notification variant} both the connection between the view and the model and controller respectively are removed.
When a change in the model occurs, the view and the controller are updated via the observer pattern.
\newpage

\subsubsection{Command Pattern}
The command pattern is used for designing user interfaces with multiple commands without using multiple if statements (if(command == x) {...} else if(command == y) ...).
It can be used to make menus reusable across applications.\\
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_command.png}
Commands as classes allow command histories and thus undo and redo.\\
Common Applications:
\begin{itemize}
  \item \textbf{Command Manager} Central repository for all commands
  \item \textbf{Redo/Undo Manager}
  \item \textbf{Queue} Holds commands until others objects are ready to do something with them
  \item \textbf{Dispatcher} (e.g. keyboard event loop)
\end{itemize}
\newpage


\subsection{Creational Patterns}
Creational patterns allow a simplified view from complex instantiation processes and make the system independent from the way its objects are created, composed and represented.

\subsubsection{Factory Pattern}
A factory class handles the instantiation of objects inheriting from one superclass depending on a keyword or value.\\
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_factory.png}
\newpage

\subsubsection{Abstract Factory Pattern}
The abstract factory pattern is used to instantiate or initialize an object consisting of more subparts.
Every implementation of the abstract factory creates a set of components consisting of a variant of every part of the whole object.
Structure:\\
\includegraphics[width=\linewidth]{images/pattern_abstract_factory.png}
\newpage
